---
title: "Trophic ecology"
format: 
  html:
    self-contained: false
    code-fold: true
editor: source
theme: minty
keep-md: true
execute:
  warning: false
  message : false
toc: true
toc-title: Sections
toc-location: left
page-layout: full
---

__How does the trophic structure and competitive interactions within the meso-bathypelagic fish community of the Bay of Biscay evolve along the water column? __ 

__1- Isotopic diversity indices__  

- How isotopic richness evolves with depth? 

- The species with the highest biomass have contrasting isotopic values to limit competition?

__2- Focus on segregation/overlap of niches__  

- At the community level, is there significant overlap of isotopic niches between species? 

- Is this overlap reduced when species are separated according to their sampling depth? 

- Is there more or less overlap between species belonging to the same family? 

- At the intraspecific level, does the position of the isotopic niche of a species change according to its sampling depth? 

# 1. Representativeness of the sampling + baseline variation (krill) 

## Krill data 
-  Significant variability of krill isotope signatures with depth? 
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| label: krill_data

# Load library
library(dplyr)
library(ggplot2)

# Load data
isotope_data <-  utils::read.csv(here::here("data","raw-data", "isotopic_data_2021.csv"), sep = ";", header = T,dec = ",")
isotope_data_krill <- isotope_data %>% filter (species == "Meganyctiphanes_norvegica")

first_plot <- ggplot(data = isotope_data_krill, aes(x = d13c, y = d15n)) + 
  geom_point(aes(color= factor(trawling_depth)), size = 3) +
  ylab(expression(paste(delta^{15}, "N (\u2030)"))) +
  xlab(expression(paste(delta^{13}, "C (\u2030)"))) + 
  theme(text = element_text(size=16)) + 
  theme_light()+
  paletteer::scale_color_paletteer_d("rcartocolor::Teal")

# Summarise By depth 
data_krill_sum <- isotope_data_krill %>% 
  group_by(trawling_depth) %>% 
  summarise(count = n(),
            mC = mean(d13c), 
            sdC = sd(d13c), 
            mN = mean(d15n), 
            sdN = sd(d15n))

second_plot <- first_plot +
  geom_errorbar(data = data_krill_sum,
                mapping = aes(x = mC, y = mN, ymin = mN - 1.96*sdN, ymax = mN + 1.96*sdN, col = factor(trawling_depth)), 
                width = 0, size=0.8) +
  geom_errorbarh(data = data_krill_sum, 
                 mapping = aes(x = mC, y = mN,xmin = mC - 1.96*sdC, xmax = mC + 1.96*sdC, col = factor(trawling_depth)),
                 height = 0, size=0.8) + 
  geom_point(data = data_krill_sum, 
             aes(x = mC, y = mN, fill = factor(trawling_depth),col = factor(trawling_depth), shape = factor(trawling_depth)),
             size = 5) +
  scale_shape_manual(values = c(21, 22, 23, 24, 25, 8, 7))+
  paletteer::scale_fill_paletteer_d("rcartocolor::Teal")+
  paletteer::scale_color_paletteer_d("rcartocolor::Teal")+
  labs(shape="Trawling depth (m)", col="Trawling depth (m)", fill= "Trawling depth (m)" )

print(second_plot)

```

## Sampling
Percentage of the diversity sampled by depth layer : 

- Epipelagic : 45%
- Upper-mesopelagic: 33%
- Lower-mesopelagic : 28%
- Bathypelagic : 15%

Percentage of the biomass sampled by depth layer : 

- Epipelagic : 96%
- Upper-mesopelagic: 90% 
- Lower-mesopelagic : 54% ( _A.carbo_ 18%)
- Bathypelagic : 60% ( _A.carbo_ 10%)


# 2. Isotopic diversity index 

## Formatting of data and calculation of relative biomasses within each depth layer 

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| label: data_formatting

# Load data 
isotope_data_fish <- isotope_data %>% filter (species != "Meganyctiphanes_norvegica")

# sourcing the R functions from 'si_div' R script
source("R/si_div.R")

# Format indiviudal_si
individuals_si <- isotope_data_fish %>%
  select(individual_code, station, d13c, d15n, species_code) %>%
  rename(indiv_ID=individual_code,
         d13C= d13c,
         d15N =d15n,
         Species_code= species_code)%>%
  mutate(depth_layer = case_when(station %in% c("Z0508") ~"epipelagic",
                                 station %in% c("Z0492", "Z0512") ~"upper_mesopelagic",
                                 station %in% c("Z0503", "Z0518") ~"lower_mesopelagic",
                                 station %in% c("Z0524","Z0497") ~"bathypelagic"))%>%
  select(-station)%>%
  arrange(Species_code)


# Format species_status_biomass with complete data of evhoe 2021
# use of all EVHOE 2021 catch data to calculate relative biomasses (not just individuals sampled for isotope)
catch_data_evhoe21 <-  utils::read.csv(here::here("data","raw-data", "data_catch_2021_mesopelagic_sp_sampled.csv"), sep = ";", header = T,
                                       dec = ".")

species_status_biomass <- catch_data_evhoe21%>%
  mutate(depth_layer = case_when(Code_Station %in% c("Z0508") ~"epipelagic",
                                 Code_Station %in% c("Z0492", "Z0512") ~"upper_mesopelagic",
                                 Code_Station %in% c("Z0503", "Z0518") ~"lower_mesopelagic",
                                 Code_Station %in% c("Z0524","Z0497") ~"bathypelagic"))%>%
  select(Code_Station, Tot_V_HV, Nom_Scientifique, depth_layer, Species_code, family)%>%
  distinct()%>%
  group_by(Nom_Scientifique, depth_layer)%>%
  mutate(biomass_sp=sum(Tot_V_HV))%>%
  select(-c(Code_Station, Tot_V_HV))%>%
  distinct()%>%
  group_by(depth_layer)%>%
  mutate(biomass_tot=sum(biomass_sp))%>%
  mutate(rel_Biomass=biomass_sp/biomass_tot*100)%>%
  select(-c(biomass_sp,  biomass_tot))%>%
  rename(Species_name= Nom_Scientifique,
         Status=depth_layer,
         Order=family)%>%
  relocate(Status, .after=Order)%>%
  relocate(rel_Biomass, .after=Species_code)%>%
  arrange(Species_code)

```

## Definitions:

- __Isotopic richness__ : increases when the space occupied by the species (convex hull) is large 

- __Isotopic divergence__ : tends to 1 when all points (or their weights) are located at the edge of the convex hull, i.e. when the oragnisms with the most extreme isotopic values dominate the food web

- __Isotopic dispersion__: equal to 1 when most points (or their weights) are far from the center of gravity of the point group, i.e. when organisms tend to have contrasting isotopic values 

- __Isotopic evenness__: tends to 1 when all organisms are equally distributed in isotopic space

- __Isotopic uniqueness__: tends to 1 when most organisms (or their weights) are isolated in isotopic space, i.e. when most organisms (or those with the highest abundance) are isolated in isotopic space, their isotopic values are very different from the rest of the organisms 

## Calculation of indices within each depth layer 

- How to divide the depth layers? One station at 1000m and another at 1010, one of which is near the bottom: to be treated separately? 

- If percentage of sampled diversity low, use of  isotopic diversity indices relevant? % biomass sampled within each depth layer is high (especially if _A. carbo_ is excluded, and each most important species in terms of biomass have been sampled in each depth layer) and the indices are correlated to the biomass, so they remain relevant? 

- only the richness is not related to the biomass: to keep? 


### Epipelagic

- station at 25m, 5 species sampled 

- Low isotopic richness, the species with the highest biomasses have contrasted isotopic values and these species dominate the food web at this depth in terms of biomass ( _N. bolini_ and M. _muelleri_)

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| label: indices_epipelagic

# Epipelagic layer ----
individuals_si_epipelagic <- individuals_si%>%
  filter(depth_layer=="epipelagic")%>%
  select(-depth_layer)

status_biomass_epipelagic <- species_status_biomass%>%
  filter(Status=="epipelagic")

# computing mean Stable Isotope values for each species
# "group" column identical to species_code to fit with input format of function meanSI_group
# no "weight" input as number of indivuals sampled per species did not mirror actual species biomass
individuals_si_ep<-data.frame(group=individuals_si_epipelagic[,"Species_code"], individuals_si_epipelagic)
mean_si_species_ep<-meanSI_group(individuals_si_ep)

# computing coefficent of variation within each species to assess intraspecific variability
cbind(CV_d13C=mean_si_species_ep[,"sd_d13C"]/mean_si_species_ep[,"d13C"], CV_d15N=mean_si_species_ep[,"sd_d15N"]/mean_si_species_ep[,"d15N"] )
# -> intraspecific variability is overall low (<20%)

# checking that species codes are the same in the two tables
#row.names(mean_si_species)==status_biomass_epipelagic[,"Species_code"] # OK

# building a single dataframe with all data for computing isotopic diversity indices
data_fish_ep<-data.frame(mean_si_species_ep[,c("d13C","d15N", "sd_d13C","sd_d15N")], rel_Biomass=status_biomass_epipelagic[,"rel_Biomass"], Status=status_biomass_epipelagic[,"Status"], latin_name=status_biomass_epipelagic[,"Species_name"])

# scaling mean stable isotopes values using function "scale_rge01"
data_fish_scl_ep<-scaleSI_range01(data_fish_ep)

# computing isotopic diversity of the whole fish assemblage using scaled isotopic values and species relative biomass
ID_scl_ab_ep<-IDiversity(cons=data_fish_scl_ep, weight=data_fish_scl_ep[,c("rel_Biomass")], nm_plot="epipelagic")

# printing results
result <- as.data.frame(round(ID_scl_ab_ep,3)) 
knitr::kable(result)

```


![epipelagic](epipelagic_d13C_d15N.jpeg){width="550"}

### Upper-mesopelagic

-  2 stations : 370 & 555m, 6 species sampled

- Low isotopic richness but species with the highest biomass ( _N.kroyeri_ & _X. copei_) are located at the edge of the convex hull, with contrasting isotopic values. The species are rather evenly distributed and isolated in the isotopic space. 
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| label: indices_upper_mesopelagic

# upper_mesopelagic layer ----
individuals_si_upper_meso <- individuals_si%>%
  filter(depth_layer=="upper_mesopelagic")%>%
  select(-depth_layer)

status_biomass_upper_meso <- species_status_biomass%>%
  filter(Status=="upper_mesopelagic")

# computing mean Stable Isotope values for each species
# "group" column identical to species_code to fit with input format of function meanSI_group
# no "weight" input as number of indivuals sampled per species did not mirror actual species biomass
individuals_si_um<-data.frame(group=individuals_si_upper_meso[,"Species_code"], individuals_si_upper_meso)
mean_si_species_um<-meanSI_group(individuals_si_um)

# computing coefficent of variation within each species to assess intraspecific variability
cbind(CV_d13C=mean_si_species_um[,"sd_d13C"]/mean_si_species_um[,"d13C"], CV_d15N=mean_si_species_um[,"sd_d15N"]/mean_si_species_um[,"d15N"] )
# -> intraspecific variability is overall low (<20%)

# checking that species codes are the same in the two tables
#row.names(mean_si_species_um)==status_biomass_upper_meso[,"Species_code"] # OK

# building a single dataframe with all data for computing isotopic diversity indices
data_fish_um <-data.frame(mean_si_species_um[,c("d13C","d15N", "sd_d13C","sd_d15N")], rel_Biomass=status_biomass_upper_meso[,"rel_Biomass"], Status=status_biomass_upper_meso[,"Status"], latin_name=status_biomass_upper_meso[,"Species_name"])

# scaling mean stable isotopes values using function "scale_rge01"
data_fish_scl_um<-scaleSI_range01(data_fish_um)

# computing isotopic diversity of the whole fish assemblage using scaled isotopic values and species relative biomass
ID_scl_ab_um<-IDiversity(cons=data_fish_scl_um, weight=data_fish_scl_um[,c("rel_Biomass")], nm_plot="upper_mesopelagic")

# printing results
result <- as.data.frame(round(ID_scl_ab_um,3)) 
knitr::kable(result)

```
![upper_mesopelagic](upper_mesopelagic_d13C_d15N.jpeg){width="550"}

### Lower-mesopelagic

-  2 stations : 715 & 1000m, 9 species sampled

- Isotopic richness slightly higher. In contrast, all other indices are rather low: the species with the largest biomasses (especially _L.crocodilus_) are located in the center of the isotopic space and do not have very contracted isotopic values. The species are not evenly distributed in the isotopic space. 

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| label: indices_lower_mesopelagic

#Lower mesopelagic layer ----
individuals_si_lower_meso <- individuals_si%>%
  filter(depth_layer=="lower_mesopelagic")%>%
  select(-depth_layer)

status_biomass_lower_meso <- species_status_biomass%>%
  filter(Status=="lower_mesopelagic")

# computing mean Stable Isotope values for each species
# "group" column identical to species_code to fit with input format of function meanSI_group
# no "weight" input as number of indivuals sampled per species did not mirror actual species biomass
individuals_si_lm<-data.frame(group=individuals_si_lower_meso[,"Species_code"], individuals_si_lower_meso)
mean_si_species_lm<-meanSI_group(individuals_si_lm)

# computing coefficent of variation within each species to assess intraspecific variability
cbind(CV_d13C=mean_si_species_lm[,"sd_d13C"]/mean_si_species_lm[,"d13C"], CV_d15N=mean_si_species_lm[,"sd_d15N"]/mean_si_species_lm[,"d15N"] )
# -> intraspecific variability is overall low (<20%)

# checking that species codes are the same in the two tables
#row.names(mean_si_species_lm)==status_biomass_lower_meso[,"Species_code"] # OK

# building a single dataframe with all data for computing isotopic diversity indices
data_fish_lm <-data.frame(mean_si_species_lm[,c("d13C","d15N", "sd_d13C","sd_d15N")], rel_Biomass=status_biomass_lower_meso[,"rel_Biomass"], Status=status_biomass_lower_meso[,"Status"], latin_name=status_biomass_lower_meso[,"Species_name"])

# scaling mean stable isotopes values using function "scale_rge01"
data_fish_scl_lm<-scaleSI_range01(data_fish_lm)

# computing isotopic diversity of the whole fish assemblage using scaled isotopic values and species relative biomass
ID_scl_ab_lm<-IDiversity(cons=data_fish_scl_lm, weight=data_fish_scl_lm[,c("rel_Biomass")], nm_plot="lower_mesopelagic")

# printing results
result <- as.data.frame(round(ID_scl_ab_lm,3)) 
knitr::kable(result)

```
![lower_mesopelagic](lower_mesopelagic_d13C_d15N.jpeg){width="550"}

### Bathypelagic

-  2 stations : 1010 (close to the bottom) & 1335m, 7 species sampled

- The species with the highest biomass, _L.crocodilus_, shows extreme isotopic values compared to the rest of the community (high divergence index and uniqueness)

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| label: indices_bathypelagic

#Lower mesopelagic layer ----
individuals_si_bathypelagic <- individuals_si%>%
  filter(depth_layer=="bathypelagic")%>%
  select(-depth_layer)

status_biomass_bathypelagic <- species_status_biomass%>%
  filter(Status=="bathypelagic")

# computing mean Stable Isotope values for each species
# "group" column identical to species_code to fit with input format of function meanSI_group
# no "weight" input as number of indivuals sampled per species did not mirror actual species biomass
individuals_si_b<-data.frame(group=individuals_si_bathypelagic[,"Species_code"], individuals_si_bathypelagic)
mean_si_species_b<-meanSI_group(individuals_si_b)

# computing coefficent of variation within each species to assess intraspecific variability
cbind(CV_d13C=mean_si_species_b[,"sd_d13C"]/mean_si_species_b[,"d13C"], CV_d15N=mean_si_species_b[,"sd_d15N"]/mean_si_species_b[,"d15N"] )
# -> intraspecific variability is overall low (<20%)

# checking that species codes are the same in the two tables
#row.names(mean_si_species_b)==status_biomass_bathypelagic[,"Species_code"] # OK

# building a single dataframe with all data for computing isotopic diversity indices
data_fish_b <-data.frame(mean_si_species_b[,c("d13C","d15N", "sd_d13C","sd_d15N")], rel_Biomass=status_biomass_bathypelagic[,"rel_Biomass"], Status=status_biomass_bathypelagic[,"Status"], latin_name=status_biomass_bathypelagic[,"Species_name"])

# scaling mean stable isotopes values using function "scale_rge01"
data_fish_scl_b<-scaleSI_range01(data_fish_b)

# computing isotopic diversity of the whole fish assemblage using scaled isotopic values and species relative biomass
ID_scl_ab_b<-IDiversity(cons=data_fish_scl_b, weight=data_fish_scl_b[,c("rel_Biomass")], nm_plot="bathypelagic")

# printing results
result <- as.data.frame(round(ID_scl_ab_lm,3)) 
knitr::kable(result)

```
![bathypelagic](bathypelagic_d13C_d15N.jpeg){width="550"}

## Evolution of trophic diversity indices with depth 

- The lower mesopelagic layer stands out with low indices for all measurements (except richness). Within this layer the species with the highest biomass (especially _L.crocodilus_) are located near the centre  of the convex hull with relatively similar isotopic values (no species with rare isotopic values). It is also the depth layer with the highest number of species sampled. 

- Within the other stations the divergence is high, i.e. the species that dominate the food web in terms of biomass have extreme isotopic values. 

- The upper mesopelagic layer also stands out with high values for all indices. It has the highest uniqueness and evenness values, which means that the species with the largest biomass are isolated in the isotopic space but also that the species are equally distributed. Indeed, the two species with the highest biomass ( _X.copei, N.kroyeri_) are located on opposite sides of the isotopic space. 

```{r}
#| echo: true
#| label: trophic_indices_df
#| fig-width: 10
#| fig-height: 7

# load library
library(ggplot2)
library(tidyr)

depth <- c("epipelagic", "upper_mesopelagic", "lower_mesopelagic", "bathypelagic" )
richness <- c(0.306, 0.287, 0.477, 0.441)
divergence <- c(0.953, 0.867, 0.561, 0.971)
disperion <- c(0.898, 0.827, 0.447, 0.516)
evenness <- c(0.446, 0.755, 0.535, 0.442)
uniqueness <- c(0.564, 0.797, 0.448, 0.765)

isotopic_indices <- 
  data.frame(depth, richness, divergence, disperion, evenness, uniqueness) %>%
  pivot_longer(
    cols = c(richness, divergence, disperion, evenness, uniqueness),
    names_to = "indices")

isotopic_indices$depth <- factor(isotopic_indices$depth, levels=c("epipelagic", "upper_mesopelagic",
                                                                 "lower_mesopelagic", "bathypelagic"))
ggplot(isotopic_indices, aes(x=depth, y=value))+
  geom_point(aes(col=depth), size=2.3)+
  facet_wrap(~indices)+
  scale_color_manual(values = c("#93c3ff","#74a8ff","#538def","#2c73d2"))+
  theme_light()+ 
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1),
        legend.position = "none")+
  xlab("")
  
```

# 3. Isotopic niches: segregation vs overlap 

```{r}
#| echo: false
#| warning: false
#| code-fold: true

# Library
library(dplyr)
library(ggplot2)
library(ellipse)

# load data 
isotope_data <-  utils::read.csv(here::here("data","raw-data", "isotopic_data_2021.csv"), sep = ";", header = T,dec = ",")
isotope_data_fish <- isotope_data %>%
  filter (species != "Meganyctiphanes_norvegica")%>%
  arrange(species)

```

## Community level

-  ellipses at 40%
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| fig-width: 10
#| fig-height: 8
#| label: community_ellipses

nichecol <- c("#E4A33A","#F67451","#D664BE", "#3DA5D9", "#94b3ae",
              "#18206F","#FD151B","#049A8F","#072AC8", "purple",
               "#d193f7","#d8c2ab","#678FCB","#A63A49","#00547A", "#6B54A0")


community_plot <- ggplot(data = isotope_data_fish, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2.3) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_shape_manual(values =c(15, 16, 17, 8, 19, 18, 3, 13, 6) )+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()

# Ellipses
# How big the ellipse 
p.ell <- 0.40
ellipse_community <- community_plot + 
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.2, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

print(ellipse_community)

```
### Overlap between species with ellipses at 40%

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| fig-width: 9
#| fig-height: 6
#| label: community_overlaps

# OVERLAP between species, all depth ----
test.elp_community <- rKIN::estEllipse(data= isotope_data_fish,  x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_community <- rKIN::getArea(test.elp_community)

# determine polygon overlap for all polygons
elp.olp_community <- rKIN::calcOverlap(test.elp_community)
elp.olp_community_melt <- reshape2::melt(elp.olp_community, na.rm = TRUE)

ggplot(elp.olp_community_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

## By depth layer 

### Epipelagic
```{r}
#| echo: false
#| warning: false
#| label: niche_epipelagic
#| fig-align: center

epipelagic_niche <- isotope_data_fish %>% filter(station == "Z0508")
nichecol <- c("#FD151B","#072AC8","#d193f7","#d8c2ab","#678FCB")

ggplot(data = epipelagic_niche, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 6
#| fig-width: 7
#| fig-align: center
#| label: overlap_epipelagic

# estimate niche overlap
test.elp_epi <- rKIN::estEllipse(data= epipelagic_niche, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_epi <- rKIN::getArea(test.elp_epi)

# determine polygon overlap for all polygons
elp.olp_epi <- rKIN::calcOverlap(test.elp_epi)
elp.olp_epi_melt <- reshape2::melt(elp.olp_epi, na.rm = TRUE)


ggplot(data = elp.olp_epi_melt , aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))
```


### Upper-mesopelagic
```{r}
#| echo: false
#| warning: false
#| label: niche_upper_meso
#| fig-align: center

upper_meso_niche <- isotope_data_fish %>% filter(station %in% c("Z0512","Z0492"))
nichecol <- c("#E4A33A","#F67451","#94B3AE","#d193f7","#678FCB","#6B54A0")

ggplot(data =upper_meso_niche, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 6
#| fig-width: 7
#| fig-align: center
#| label: overlap_upper_meso

# estimate niche overlap
test.elp_upper_meso <- rKIN::estEllipse(data= upper_meso_niche, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_upper_meso <- rKIN::getArea(test.elp_upper_meso)

# determine polygon overlap for all polygons
elp.olp_upper_meso <- rKIN::calcOverlap(test.elp_upper_meso)
elp.olp_upper_meso_melt <- reshape2::melt(elp.olp_upper_meso, na.rm = TRUE)

ggplot(data = elp.olp_upper_meso_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

### Lower-mesopelagic
```{r}
#| echo: false
#| warning: false
#| label: niche_lower_meso
#| fig-align: center

lower_meso_niche <- isotope_data_fish %>% filter(station %in% c("Z0503","Z0518"))

nichecol <- c("#E4A33A","#F67451","#D664BE", "#3DA5D9",
              "#94B3AE","#049A8F", "#A63A49","#00547A","#6B54A0")
              
ggplot(data =lower_meso_niche, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 6
#| fig-width: 7
#| fig-align: center
#| label: overlap_lower_meso

# estimate niche overlap
test.elp_lower_meso <- rKIN::estEllipse(data= lower_meso_niche, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_lower_meso <- rKIN::getArea(test.elp_lower_meso)

# determine polygon overlap for all polygons
elp.olp_lower_meso <- rKIN::calcOverlap(test.elp_lower_meso)
elp.olp_lower_meso_melt <- reshape2::melt(elp.olp_lower_meso, na.rm = TRUE)

ggplot(data = elp.olp_lower_meso_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

### Bathypelagic
```{r}
#| echo: false
#| warning: false
#| label: niche_bathypelagic
#| fig-align: center

bathypelagic_niche <- isotope_data_fish %>% filter(station %in% c("Z0524","Z0497"))
nichecol <- c("#F67451","#94B3AE","#18206F","purple","#d193f7","#00547A","#6B54A0")
              
ggplot(data =bathypelagic_niche, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+ 
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 6
#| fig-width: 7
#| fig-align: center
#| label: overlap_bathypelagic

# estimate niche overlap
test.elp_bathypelagic <- rKIN::estEllipse(data= bathypelagic_niche, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_bathypelagic <- rKIN::getArea(test.elp_bathypelagic)

# determine polygon overlap for all polygons
elp.olp_bathypelagic <- rKIN::calcOverlap(test.elp_bathypelagic)
elp.olp_bathypelagic_melt <- reshape2::melt(elp.olp_bathypelagic, na.rm = TRUE)

ggplot(data = elp.olp_bathypelagic_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

## By station 

### Station Z0492 - 370m
```{r}
#| echo: false
#| warning: false
#| label: niche_Z0492
#| fig-align: center

station_z0492 <- isotope_data_fish %>% filter(station == "Z0492")
nichecol <- c("#E4A33A","#F67451","#94B3AE","#d193f7","#678FCB","#6B54A0")


ggplot(data = station_z0492, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
#| label: overlap_z0492

# estimate niche overlap
test.elp_Z0492<- rKIN::estEllipse(data= station_z0492, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_Z0492 <- rKIN::getArea(test.elp_Z0492)

# determine polygon overlap for all polygons
elp.olp_Z0492 <- rKIN::calcOverlap(test.elp_Z0492)
elp.olp_Z0492_melt <- reshape2::melt(elp.olp_Z0492, na.rm = TRUE)

ggplot(data = elp.olp_Z0492_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  ggtitle("Overlap using Kernel utilization density")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

### Station Z0512 - 555m
```{r}
#| echo: false
#| warning: false
#| fig-align: center
#| label: niche_Z0512

station_z0512 <- isotope_data_fish %>% filter(station == "Z0512")
nichecol <- c("#E4A33A","#F67451","#94b3ae","#678FCB","#6B54A0")

ggplot(data = station_z0512, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
#| label: overlap_z0512

# estimate niche overlap
test.elp_z0512 <- rKIN::estEllipse(data= station_z0512, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_Z0512 <- rKIN::getArea(test.elp_z0512)

# determine polygon overlap for all polygons
elp.olp_Z0512 <- rKIN::calcOverlap(test.elp_z0512)
elp.olp_Z0512_melt <- reshape2::melt(elp.olp_Z0512, na.rm = TRUE)

ggplot(data = elp.olp_Z0512_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  ggtitle("Overlap using Kernel utilization density")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

### Station Z0503 - 715m
```{r}
#| echo: false
#| warning: false
#| label: niche_Z0503
#| fig-align: center

station_z0503 <- isotope_data_fish %>% filter(station == "Z0503")
nichecol <- c("#E4A33A","#3DA5D9","#94B3AE","#00547A","#6B54A0")

ggplot(data = station_z0503, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")
```

```{r}
#| echo: false
#| warning: false
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
#| label: overlap_z0503

# estimate niche overlap
test.elp_z0503 <- rKIN::estEllipse(data= station_z0503, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_Z0503 <- rKIN::getArea(test.elp_z0503)

# determine polygon overlap for all polygons
elp.olp_z0503 <- rKIN::calcOverlap(test.elp_z0503)
elp.olp_z0503_melt <- reshape2::melt(elp.olp_z0503, na.rm = TRUE)

ggplot(data = elp.olp_z0503_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  ggtitle("Overlap using Kernel utilization density")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))
```

### Station Z0518 - 1000m
```{r}
#| echo: false
#| warning: false
#| label: niche_Z0518
#| fig-align: center

station_z0518 <- isotope_data_fish %>% filter(station == "Z0518")
nichecol <- c("#F67451","#D664BE","#94B3AE",
              "#049A8F","#A63A49","#00547A")

ggplot(data = station_z0518, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
#| label: overlap_z0518

# estimate niche overlap
test.elp_z0518 <- rKIN::estEllipse(data= station_z0518, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_Z0518 <- rKIN::getArea(test.elp_z0518)

# determine polygon overlap for all polygons
elp.olp_z0518 <- rKIN::calcOverlap(test.elp_z0518)
elp.olp_z0518_melt <- reshape2::melt(elp.olp_z0518, na.rm = TRUE)

ggplot(data = elp.olp_z0518_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  ggtitle("Overlap using Kernel utilization density")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```

### Station Z0524 - 1010m

-  Station sampled near the bottom (<100m)

-  _A. olfersii_: only 3 samples, ellipse not performed 
```{r}
#| echo: false
#| warning: false
#| label: niche_Z0524
#| fig-align: center

station_z0524 <- isotope_data_fish %>% filter(station == "Z0524")
nichecol <- c("#F67451","#94B3AE","purple","#00547A","#6B54A0")

ggplot(data = station_z0524, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
#| label: overlap_z0524

# estimate niche overlap
test.elp_z0524 <- rKIN::estEllipse(data= station_z0524, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_Z0524 <- rKIN::getArea(test.elp_z0524)

# determine polygon overlap for all polygons
elp.olp_z0524 <- rKIN::calcOverlap(test.elp_z0524)
elp.olp_z0524_melt <- reshape2::melt(elp.olp_z0524, na.rm = TRUE)

ggplot(data = elp.olp_z0524_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  ggtitle("Overlap using Kernel utilization density")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))
```

### Station Z0497 - 1335m
```{r}
#| echo: false
#| warning: false
#| label: niche_Z0497
#| fig-align: center

station_z0497 <- isotope_data_fish %>% filter(station == "Z0497")
nichecol <- c("#F67451","#94B3AE","#18206F","#d193f7","#00547A","#6B54A0")

ggplot(data = station_z0497, 
                     aes(x = d13c, 
                         y = d15n)) + 
  geom_point(aes(color = species, shape= family), size = 2, alpha= 0.8) +
  scale_color_manual(values=nichecol)+
  scale_fill_manual(values=nichecol)+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+ 
  theme(text = element_text(size=16)) + 
  theme_light()+
  stat_ellipse(aes(group = species, 
                   fill = species, 
                   color = species), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

```{r}
#| echo: false
#| warning: false
#| fig-height: 4
#| fig-width: 5
#| fig-align: center
#| label: overlap_z0497

# estimate niche overlap
test.elp_z0497 <- rKIN::estEllipse(data= station_z0497, x="d13c", y="d15n", group="species", levels=40, smallSamp = TRUE)

# Extract the area of each polygon
elp.area_Z0497 <- rKIN::getArea(test.elp_z0497)

# determine polygon overlap for all polygons
elp.olp_z0497 <- rKIN::calcOverlap(test.elp_z0497)
elp.olp_z0497_melt <- reshape2::melt(elp.olp_z0497, na.rm = TRUE)

ggplot(data = elp.olp_z0497_melt, aes(x=OverlapID, y=variable, fill=value)) + 
  geom_tile(alpha=0.85)+
  theme_minimal()+ 
  scale_fill_gradient(high = "darkblue", low="grey99", limits=c(0,1))+
  geom_text(aes(label = value), color = "black", size = 3.5) +
  xlab("")+
  ylab("")+
  ggtitle("Overlap using Kernel utilization density")+
  theme(axis.text.x = element_text(angle = 45, vjust = 1,size = 8, hjust = 1), 
        axis.text.y = element_text(size=8),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8))

```


## cluster

- cluster with the community-level overlap matrix as input (without depth division)

__cluster 1__ : 

-  S. koefoedi & M. argipalla, high overlap, same depth, same family
-  L. macdonaldi & S. koefoedi : different depth distribution

__cluster 2__: 

- N. kroyeri et N. bolini, same depth distribution, same family
- N.kroyeri hada high overlap with M.atlanticum and Cyclothone but different depth distribution (same for N. bolini and M. atlanticum)
- Cyclothone and M.atlanticum: not in the same depth layer (but same depth distribution)

__cluster3__: 

- A. olfersii had a high overlap with L. crocodilus and M.punctatum (station at 1000 and 370m)
- M.punctatum & L.crocodilus: in the upper-mesopelagic assemblage (not in station) 

__cluster4__: 

-  L. sphyrenoides & A.risso: not the same depth distribution, same family 

__cluter 5__:

- X. copei & M. muelleri: not the same depth distribution
```{r}
#| echo: true
#| warning: false
#| fig-height: 7
#| fig-width: 8
#| fig-align: center
#| label: cluster

elp.olp_community_mt <- elp.olp_community%>%
  tibble::column_to_rownames(var="OverlapID")

df <- as.data.frame(scale(elp.olp_community_mt)) 

# Elbow method
# factoextra::fviz_nbclust(df, kmeans, method = "wss") +
#   labs(subtitle = "Elbow method")

# Silhouette method
# factoextra::fviz_nbclust(df, kmeans, method = "silhouette")+
#   labs(subtitle = "Silhouette method")

# Gap statistic
# factoextra::fviz_nbclust(df, kmeans, nstart = 25, 
#                          method = "gap_stat", nboot = 500, 
#                          verbose = FALSE)+
#   labs(subtitle = "Gap statistic method")

res.km <- kmeans(scale(df), 5, nstart = 25)
# K-means clusters showing the group of each individuals
#res.km$cluster

factoextra::fviz_cluster(res.km, data = df, 
                         palette=c("#7b95cc", "#007A75", "#D96681", "#150578", "#BF9AD8"),
                         ellipse.type = "convex",
                         ggtheme = theme_minimal())

# # Dimension reduction using PCA
# res.pca <- prcomp(df,  scale = TRUE)
# # Coordinates of individuals
# ind.coord <- as.data.frame(factoextra::get_pca_ind(res.pca)$coord)
# # Add clusters obtained using the K-means algorithm
# ind.coord$cluster <- factor(res.km$cluster)
# # Add Species groups from the original data sett
# ind.coord$Species <- df$Species
# # Data inspection
# head(ind.coord)
# 
# # Percentage of variance explained by dimensions
# eigenvalue <- round(factoextra::get_eigenvalue(res.pca), 1)
# variance.percent <- eigenvalue$variance.percent
# head(eigenvalue)

```
```{r}
#| echo: true
#| warning: false
#| fig-height: 7
#| fig-width: 8
#| fig-align: center
#| label: cluster_niche

cluster_data <- isotope_data_fish%>%
  mutate(cluster= case_when(species%in% c("Lampanyctus_macdonaldi", "Searsia_koefoedi", "Maulisia_argipalla") ~"A",
                            species%in% c("Cyclothone", "Notoscopelus_bolini", "Notoscopelus_kroyeri", 
                                           "Melanostigma_atlanticum")~"B",
                            species%in% c("Lampanyctus_crocodilus","Argyropelecus_olfersii", 
                                          "Benthosema_glaciale", "Serrivomer_beanii",
                                          "Myctophum_punctatum")~"C",
                            species%in% c("Arctozenus_risso", "Lestidiops_sphyrenoides")~"D",
                            species%in% c("Xenodermichthys_copei", "Maurolicus_muelleri")~"E"))


cluster_plot <- ggplot(data = cluster_data, 
                         aes(x = d13c, 
                             y = d15n)) + 
  geom_point(aes(color = cluster, fill=cluster), size = 1.5, alpha=0.5) +
  scale_color_manual(values= c("#7b95cc", "#007A75", "#D96681", "#150578", "#BF9AD8"))+
  scale_fill_manual(values=c("#7b95cc", "#007A75", "#D96681", "#150578", "#BF9AD8"))+
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()

# Ellipses
# How big the ellipse 
p.ell <- 0.40
ellipse_cluster <- cluster_plot + 
  stat_ellipse(aes(group = species, 
                   fill = cluster, 
                   color = cluster), 
               alpha = 0.1, 
               level = p.ell,
               linewidth = 0.8,
               type = "norm",
               geom = "polygon")
print(ellipse_cluster)
```


## Distribution
```{r}
#| echo: false
#| warning: false
#| fig-width: 14
#| fig-height: 8
#| label: density_plot

catch_data_evhoe21 <-  utils::read.csv(here::here("data","raw-data", "data_catch_2021_mesopelagic.csv"), sep = ";", header = T,
                                       dec = ".")

density_distribution <- catch_data_evhoe21%>%
  select(Nom_Scientifique, Tot_V_HV, Code_Station)%>%
  filter(Nom_Scientifique%in%c("Arctozenus risso", "Argyropelecus olfersii", "Benthosema glaciale",
                               "Cyclothone", "Lampanyctus crocodilus", "Lampanyctus macdonaldi",
                               "Lestidiops sphyrenoides", "Maulisia argipalla", "Maurolicus muelleri",
                               "Melanostigma atlanticum", "Myctophum punctatum", "Notoscopelus bolini",
                               "Notoscopelus kroyeri", "Searsia koefoedi", "Serrivomer beanii","Xenodermichthys copei"))%>%
  mutate(trawling_depth= case_when(Code_Station %in% c("Z0508") ~25,
                                   Code_Station %in% c("Z0492") ~370,
                                   Code_Station%in% c("Z0512") ~555,
                                   Code_Station %in% c("Z0503") ~715,
                                   Code_Station %in% c("Z0518") ~1000,
                                   Code_Station %in% c("Z0524") ~1010,
                                   Code_Station %in% c("Z0497") ~1335))%>%
  mutate(bottom_proximity= case_when(Code_Station %in% c("Z0508") ~3516,
                                   Code_Station %in% c("Z0492") ~1290,
                                   Code_Station%in% c("Z0512") ~1625,
                                   Code_Station %in% c("Z0503") ~1500,
                                   Code_Station %in% c("Z0518") ~1284,
                                   Code_Station %in% c("Z0524") ~110,
                                   Code_Station %in% c("Z0497") ~1124))%>%
  distinct()%>%
  group_by(Nom_Scientifique)%>%
  mutate(sum_sp=sum(Tot_V_HV))%>%
  ungroup()%>%
  group_by(trawling_depth, Nom_Scientifique)%>%
  mutate(pourcentage_bio=sum(Tot_V_HV/sum_sp*100))%>%
  # Selection of trawling depht or bottom proximity 
  select(Nom_Scientifique, trawling_depth, pourcentage_bio)%>%
  # to have a round number to be able to multiply it afterwards 
  mutate(across(pourcentage_bio, round, 0)) %>%
  mutate(n_bio = as.integer(pourcentage_bio))%>%
  select(-c(pourcentage_bio))%>%
  tidyr::uncount(n_bio)

# Order in function of median depth
density_distribution$Nom_Scientifique = with(density_distribution, reorder(Nom_Scientifique, trawling_depth, median))  

ggplot(density_distribution,
       aes(x = trawling_depth, y = Nom_Scientifique, group = Nom_Scientifique, col=Nom_Scientifique, fill=Nom_Scientifique))+ 
  paletteer::scale_color_paletteer_d("pals::stepped")+
  paletteer::scale_fill_paletteer_d("pals::stepped")+
  ggridges::stat_density_ridges(quantile_lines = TRUE, quantiles = 0.5 , alpha=0.5, size=0.7)+
  theme_classic()+
  theme(axis.text.y = element_text(size=12))+
  scale_y_discrete(position = "right")+
  scale_x_reverse()+
  coord_flip()+
  ylab(label = "")+ xlab("Depth (m)")+
  theme(axis.text.y = element_text(size=14),
        axis.text.x = element_text(face="italic", size=14, angle=80,vjust = 0.5, hjust=0),
        axis.title.x = element_text(size=14),
        axis.title.y = element_text(size=14))+
  guides(fill="none", col="none" ,alpha="none")

```


## Intraspecific changes over the depth range ? Evolution of niche area (KUD) with depth
### Lampanyctus crocodilus 
```{r}
#| echo: true
#| warning: false
#| label: niche_lamp_cro
#| fig-align: center
#| fig-width: 10
#| fig-height: 6

lamp_cro_niche <- isotope_data_fish %>% filter(species=="Lampanyctus_crocodilus")
p.ell <- 0.40

ggplot(lamp_cro_niche, aes(x = d13c,y = d15n)) + 
  geom_point(aes(col=factor(trawling_depth), shape=factor(trawling_depth)), size = 2, alpha= 0.8) +
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  paletteer::scale_color_paletteer_d("LaCroixColoR::Pure")+
  paletteer::scale_fill_paletteer_d("LaCroixColoR::Pure")+
  stat_ellipse(aes(group = factor(trawling_depth), 
                   fill = factor(trawling_depth), 
                   color = factor(trawling_depth)), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

#### Calculate vector (centroids)
```{r}
#| echo: false
#| message: false
#| warning: false
#| label: niche_lamp_centroid
#| fig-align: center
#| fig-width: 17
#| fig-height: 14

Lamp_cro_vector <- isotope_data_fish%>%
  filter(species=="Lampanyctus_crocodilus")%>%
  select(-group)%>%
  mutate(group = species, 
         community = factor(trawling_depth),
         iso1=d13c,
         iso2 =d15n,
         .keep = "unused")%>%
  select(group, community, iso1, iso2)%>%
  relocate(iso1, .before = group)%>%
  relocate(iso2, .after = iso1)

# create the siber object
siber.example <- SIBER::createSiberObject(Lamp_cro_vector)

# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains

parms$save.output = FALSE
parms$save.dir = tempdir()

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the 
# means. Fitting is via the JAGS method.
ellipses.posterior <- SIBER::siberMVN(siber.example, parms, priors)

# extract the centroids from the fitted model object
centroids <- SIBER::siberCentroids(ellipses.posterior)

# calculate pairwise polar vectors among all groups
# this is not actually used in this example
angles_distances <- SIBER::allCentroidVectors(centroids, do.plot = F)


# function to do the histograms on each group
my.hist <- function(df){
  test <- hist(df$angles, 
               breaks = seq(from = -pi, to = pi, length = 60), 
               plot = FALSE)
  
  X <- data.frame(counts = test$counts, mids = test$mids, dens = test$density, 
                  counts.stdzd = test$counts / max(test$counts))
  
  return(X)
  
}
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

# calculate the points for each group's ellipse
hist.by.groups <- angles_distances %>% group_by(comparison) %>%
  do(my.hist(.))

all.roses <- ggplot(data = hist.by.groups, aes(x = mids, y = counts.stdzd)) +
  geom_bar(stat = "identity") + 
  coord_polar(start = pi / 2, direction = -1) +
  facet_wrap( ~ comparison) +
  theme(axis.ticks.y = element_blank(), 
        axis.text.y = element_blank()) + 
  scale_x_continuous( breaks = c(-pi, -pi/2, 0, pi/2, pi),
                      labels = c("","-\u03C0/2","0","\u03C0/2", "\u03C0"))
#print(all.roses)



median_vectors <- dplyr::summarise(group_by(angles_distances, comparison),
                                   medAngle = median(angles), medDist = median(distances))

origins <- data.frame(comparison = median_vectors$comparison, 
                      x = 0, y = 0)

ends    <- with(median_vectors, data.frame(comparison = comparison,
                                           x = medDist * cos(medAngle),
                                           y = medDist * sin(medAngle)))

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# generate the start and end points of the medians for the arrows
for_arrows <- dplyr::bind_rows(origins, ends)

# rename the comparison label for nice plot labels below
# aa <- unlist(strsplit(as.character(for_arrows$comparison), "[.]"))
# aa <- aa[seq(3,length(aa),5)]
# for_arrows$comparison2 <- factor(aa)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
# create the cartesian points for the estimated tips of the arrows
cart_positions <- with(angles_distances, data.frame(x = distances * cos(angles),
                                                    y = distances * sin(angles),
                                                    comparison = comparison ))

# rename as above
# bb <- unlist(strsplit(as.character(angles_distances$comparison), "[.]"))
# bb <- bb[seq(3,length(bb),5)]
# cart_positions$comparison2 <- factor(bb)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
# plot it
ggplot(cart_positions, aes(x,y) ) + 
  geom_bin2d(bins = 20) +
  scale_fill_gradient(low = "white", high = "black") +
  coord_cartesian() +
  facet_wrap( ~ comparison, scales = "fixed", ncol=3) + 
  theme_classic() +
  geom_path(data = for_arrows, 
            arrow = arrow(type = "open", length = unit(0.2, "cm")),
            col = "red", size=1.7) +
  ylab(expression(paste(delta^{15}, "N (\u2030)"))) +
  xlab(expression(paste(delta^{13}, "C (\u2030)"))) + 
  theme(text = element_text(size=15))

```



### Xenodermichthys copei
```{r}
#| echo: true
#| warning: false
#| label: niche_xeno_cop
#| fig-align: center
#| fig-width: 10
#| fig-height: 6

xeno_cop_niche <- isotope_data_fish %>% filter(species=="Xenodermichthys_copei")
p.ell <- 0.40

ggplot(xeno_cop_niche, aes(x = d13c,y = d15n)) + 
  geom_point(aes(col=factor(trawling_depth), shape=factor(trawling_depth)), size = 2, alpha= 0.8) +
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  paletteer::scale_color_paletteer_d("LaCroixColoR::Pure")+
  paletteer::scale_fill_paletteer_d("LaCroixColoR::Pure")+
  stat_ellipse(aes(group = factor(trawling_depth), 
                   fill = factor(trawling_depth), 
                   color = factor(trawling_depth)), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

#### Calculate vector (centroids)
```{r}
#| echo: false
#| message: false
#| warning: false
#| label: niche_xeno_cop_centroid
#| fig-align: center
#| fig-width: 17
#| fig-height: 14

xeno_cop_vector <- isotope_data_fish%>%
  filter(species=="Xenodermichthys_copei")%>%
  select(-group)%>%
  mutate(group = species, 
         community = factor(trawling_depth),
         iso1=d13c,
         iso2 =d15n,
         .keep = "unused")%>%
  select(group, community, iso1, iso2)%>%
  relocate(iso1, .before = group)%>%
  relocate(iso2, .after = iso1)

# create the siber object
siber.example <- SIBER::createSiberObject(xeno_cop_vector)

# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains

parms$save.output = FALSE
parms$save.dir = tempdir()

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the 
# means. Fitting is via the JAGS method.
ellipses.posterior <- SIBER::siberMVN(siber.example, parms, priors)

# extract the centroids from the fitted model object
centroids <- SIBER::siberCentroids(ellipses.posterior)

# calculate pairwise polar vectors among all groups
# this is not actually used in this example
angles_distances <- SIBER::allCentroidVectors(centroids, do.plot = F)


# function to do the histograms on each group
my.hist <- function(df){
  test <- hist(df$angles, 
               breaks = seq(from = -pi, to = pi, length = 60), 
               plot = FALSE)
  
  X <- data.frame(counts = test$counts, mids = test$mids, dens = test$density, 
                  counts.stdzd = test$counts / max(test$counts))
  
  return(X)
  
}
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

# calculate the points for each group's ellipse
hist.by.groups <- angles_distances %>% group_by(comparison) %>%
  do(my.hist(.))

all.roses <- ggplot(data = hist.by.groups, aes(x = mids, y = counts.stdzd)) +
  geom_bar(stat = "identity") + 
  coord_polar(start = pi / 2, direction = -1) +
  facet_wrap( ~ comparison) +
  theme(axis.ticks.y = element_blank(), 
        axis.text.y = element_blank()) + 
  scale_x_continuous( breaks = c(-pi, -pi/2, 0, pi/2, pi),
                      labels = c("","-\u03C0/2","0","\u03C0/2", "\u03C0"))
#print(all.roses)



median_vectors <- dplyr::summarise(group_by(angles_distances, comparison),
                                   medAngle = median(angles), medDist = median(distances))

origins <- data.frame(comparison = median_vectors$comparison, 
                      x = 0, y = 0)

ends    <- with(median_vectors, data.frame(comparison = comparison,
                                           x = medDist * cos(medAngle),
                                           y = medDist * sin(medAngle)))

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# generate the start and end points of the medians for the arrows
for_arrows <- dplyr::bind_rows(origins, ends)

# rename the comparison label for nice plot labels below
# aa <- unlist(strsplit(as.character(for_arrows$comparison), "[.]"))
# aa <- aa[seq(3,length(aa),5)]
# for_arrows$comparison2 <- factor(aa)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
# create the cartesian points for the estimated tips of the arrows
cart_positions <- with(angles_distances, data.frame(x = distances * cos(angles),
                                                    y = distances * sin(angles),
                                                    comparison = comparison ))

# rename as above
# bb <- unlist(strsplit(as.character(angles_distances$comparison), "[.]"))
# bb <- bb[seq(3,length(bb),5)]
# cart_positions$comparison2 <- factor(bb)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
# plot it
ggplot(cart_positions, aes(x,y) ) + 
  geom_bin2d(bins = 20) +
  scale_fill_gradient(low = "white", high = "black") +
  coord_cartesian() +
  facet_wrap( ~ comparison, scales = "fixed", ncol=3) + 
  theme_classic() +
  geom_path(data = for_arrows, 
            arrow = arrow(type = "open", length = unit(0.2, "cm")),
            col = "red", size=1.7) +
  ylab(expression(paste(delta^{15}, "N (\u2030)"))) +
  xlab(expression(paste(delta^{13}, "C (\u2030)"))) + 
  theme(text = element_text(size=15))

```



### Argyropelecus olfersii
```{r}
#| echo: true
#| warning: false
#| label: niche_argy_olf
#| fig-align: center
#| fig-width: 10
#| fig-height: 6

argy_olf_niche <- isotope_data_fish %>% filter(species=="Argyropelecus_olfersii")
p.ell <- 0.40

ggplot(argy_olf_niche, aes(x = d13c,y = d15n)) + 
  geom_point(aes(col=factor(trawling_depth), shape=factor(trawling_depth)), size = 2, alpha= 0.8) +
  scale_x_continuous(expression({delta}^13*C~'\u2030'), limits = c(-21, -18.5)) +
  scale_y_continuous(expression({delta}^15*N~'\u2030'), limits = c(7, 14))+
  theme(text = element_text(size=16)) + 
  theme_light()+
  paletteer::scale_color_paletteer_d("LaCroixColoR::Pure")+
  paletteer::scale_fill_paletteer_d("LaCroixColoR::Pure")+
  stat_ellipse(aes(group = factor(trawling_depth), 
                   fill = factor(trawling_depth), 
                   color = factor(trawling_depth)), 
               alpha = 0.25, 
               level = p.ell,
               linewidth = 0.7,
               type = "norm",
               geom = "polygon")

```

#### Calculate vector (centroids)
```{r}
#| echo: false
#| message: false
#| warning: false
#| label: niche_argy_olf_centroid
#| fig-align: center
#| fig-width: 17
#| fig-height: 14

argy_olf_vector <- isotope_data_fish%>%
  filter(species=="Argyropelecus_olfersii")%>%
  select(-group)%>%
  mutate(group = species, 
         community = factor(trawling_depth),
         iso1=d13c,
         iso2 =d15n,
         .keep = "unused")%>%
  select(group, community, iso1, iso2)%>%
  relocate(iso1, .before = group)%>%
  relocate(iso2, .after = iso1)

# create the siber object
siber.example <- SIBER::createSiberObject(argy_olf_vector)

# options for running jags
parms <- list()
parms$n.iter <- 2 * 10^4   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^3 # discard the first set of values
parms$n.thin <- 10     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains

parms$save.output = FALSE
parms$save.dir = tempdir()

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the 
# means. Fitting is via the JAGS method.
ellipses.posterior <- SIBER::siberMVN(siber.example, parms, priors)

# extract the centroids from the fitted model object
centroids <- SIBER::siberCentroids(ellipses.posterior)

# calculate pairwise polar vectors among all groups
# this is not actually used in this example
angles_distances <- SIBER::allCentroidVectors(centroids, do.plot = F)


# function to do the histograms on each group
my.hist <- function(df){
  test <- hist(df$angles, 
               breaks = seq(from = -pi, to = pi, length = 60), 
               plot = FALSE)
  
  X <- data.frame(counts = test$counts, mids = test$mids, dens = test$density, 
                  counts.stdzd = test$counts / max(test$counts))
  
  return(X)
  
}
# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

# calculate the points for each group's ellipse
hist.by.groups <- angles_distances %>% group_by(comparison) %>%
  do(my.hist(.))

all.roses <- ggplot(data = hist.by.groups, aes(x = mids, y = counts.stdzd)) +
  geom_bar(stat = "identity") + 
  coord_polar(start = pi / 2, direction = -1) +
  facet_wrap( ~ comparison) +
  theme(axis.ticks.y = element_blank(), 
        axis.text.y = element_blank()) + 
  scale_x_continuous( breaks = c(-pi, -pi/2, 0, pi/2, pi),
                      labels = c("","-\u03C0/2","0","\u03C0/2", "\u03C0"))
#print(all.roses)



median_vectors <- dplyr::summarise(group_by(angles_distances, comparison),
                                   medAngle = median(angles), medDist = median(distances))

origins <- data.frame(comparison = median_vectors$comparison, 
                      x = 0, y = 0)

ends    <- with(median_vectors, data.frame(comparison = comparison,
                                           x = medDist * cos(medAngle),
                                           y = medDist * sin(medAngle)))

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
# generate the start and end points of the medians for the arrows
for_arrows <- dplyr::bind_rows(origins, ends)

# rename the comparison label for nice plot labels below
# aa <- unlist(strsplit(as.character(for_arrows$comparison), "[.]"))
# aa <- aa[seq(3,length(aa),5)]
# for_arrows$comparison2 <- factor(aa)


# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
# create the cartesian points for the estimated tips of the arrows
cart_positions <- with(angles_distances, data.frame(x = distances * cos(angles),
                                                    y = distances * sin(angles),
                                                    comparison = comparison ))

# rename as above
# bb <- unlist(strsplit(as.character(angles_distances$comparison), "[.]"))
# bb <- bb[seq(3,length(bb),5)]
# cart_positions$comparison2 <- factor(bb)

# = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
# plot it
ggplot(cart_positions, aes(x,y) ) + 
  geom_bin2d(bins = 20) +
  scale_fill_gradient(low = "white", high = "black") +
  coord_cartesian() +
  facet_wrap( ~ comparison, scales = "fixed", ncol=3) + 
  theme_classic() +
  geom_path(data = for_arrows, 
            arrow = arrow(type = "open", length = unit(0.2, "cm")),
            col = "red", size=1.7) +
  ylab(expression(paste(delta^{15}, "N (\u2030)"))) +
  xlab(expression(paste(delta^{13}, "C (\u2030)"))) + 
  theme(text = element_text(size=15))

```

